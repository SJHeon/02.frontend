<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lab03_asynchronous.html</title>
</head>

<body>
    <script>
        // 동기(synchronous) : 요청 결과 응답 후 다음 동작이 실행 되는 방식
        // console.log(1);
        // setTimeout(() => { // 브라우저 내장 함수
        //     console.log(2);
        // }, 2000);
        // console.log(3);

        // 비동기(asynchronous) : 요청 결과 응답과 별개로 다음 동작이 실행 되는 방식
        // 왜 필요한가? 서버로 부터 데이터 세팅, 문제 발생시 별도로 실행 되어야 하는 경우, ...

        // 콜백 함수 CallBack Fuction
        // : 함수의 매개변수로 전달되는 함수 --> 결과적으로 콜백 함수는 전달 받은 함수 안에서 다시 호출
        // function callBack(callBack) {
        //     setTimeout(() => {
        //         callBack();
        //     }, 1000);
        // };

        // callBack(() => {
        //     console.log('1초 후에 callBack 함수 실행');
        // });
        // callBack(() => {
        //     callBack(() => {
        //         console.log('2초 후에 callBack 함수 실행');
        //     });
        // });
        // // 콜백 지옥 -> 과부하
        // callBack(() => {
        //     callBack(() => {
        //         callBack(() => {
        //             console.log('3초 후에 callBack 함수 실행');
        //         });
        //     });
        // });

        // 콜백 말고 괜찮은 거 없나?
        // Promise
        // 전역 객체 (new x)
        // console.log(Promise);

        // 문법
        // new 연산자로 Promise 객체 생성 가능
        // 객체 생성시 실행자 함수를 인자로 받아 실행
        // promise는 진행되는 시점에 따라 상태 값을 가짐
        // 실행자 함수의 종류는 2가지
        // resolve(), reject()
        // new Promise((resolve, reject) => {

        // });

        // 대기(pending) : 프로미스 객체가 생성되어 대기 중인 상태

        // 이행(fulfilled) : resolve()를 실행 시켰을 때의 상태
        // new Promise((resolve, reject) => {
        //     resolve();
        // });

        // 거부(rejected) : reject()를 실행시켰을 때의 상태
        // new Promise((resolve, reject)=>{
        //     reject()
        // });

        // 1초 후 실행 함수
        let promiseFunction = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve();
            }, 1000);
        });

        console.log(promiseFunction);
        promiseFunction.then(() => {
            console.log("프로미스 실행");
        });
    </script>
</body>

</html>